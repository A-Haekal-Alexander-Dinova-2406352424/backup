# eShop

## Reflection 1

In building the EShop features (create/list/edit/delete) I tried to keep the code organized using the MVC-style separation into `controller`, `service`, `repository`, and `model` packages. This separation makes each class have a single responsibility: the controller handles HTTP/HTML, the service handles business logic, and the repository handles data storage. I used descriptive names like `ProductServiceImpl` and small methods like `productListPage()` so the code reads like a set of use-cases. For maintainability, I avoided duplicating the “find all products” conversion logic by centralizing it in the service layer. For basic secure coding, the server generates the `productId` (UUID) instead of taking it from the client on create, so an attacker cannot choose IDs when creating new products. I also kept the data model strongly typed (e.g., `int` for quantity) and used POST endpoints for state-changing actions. A weakness in the current code is that it relies mainly on client-side `required`/`min` validation; in a real app I should add server-side validation (e.g., Bean Validation annotations and validation in controller/service) and handle invalid input with proper error messages. Another improvement would be to add authentication/authorization before allowing edits/deletes and to avoid exposing mutable objects directly from the repository.

## Reflection 2

1. After writing unit tests, I feel more confident because changes in the model/repository will be caught quickly. A reasonable number of unit tests in a class depends on the number of behaviors and edge cases the class has, not on a fixed number; I prefer grouping tests by behavior and keeping each test focused on one scenario. In practice, I try to cover both happy paths and negative cases (e.g., update/delete for non-existing products) because those are common sources of bugs. To judge whether unit tests are “enough”, I look at code coverage as a guide, but I also review whether important business rules and boundary conditions are actually asserted. Coverage can show untested lines, but it cannot guarantee that the assertions are meaningful or that all combinations of inputs are tested. Having 100% coverage does not mean the program is bug-free; tests can miss wrong requirements, have weak assertions, or fail to cover integration issues like HTTP mapping and template rendering.

2. If I copy the same setup code (serverPort, baseUrl, `@Value`, `setupTest`) into another functional test class, the code becomes repetitive and harder to maintain. The duplication itself is a clean code smell (DRY violation) because a small change in setup (e.g., base URL format) would have to be updated in multiple places. Repeating the same instance variables and boilerplate can also distract from the intent of each test case, making the tests less readable. Over time, such duplicated setup tends to drift, which can create flaky tests that behave differently even though they should be consistent. A cleaner approach would be to extract common setup into a shared base class, a helper utility, or a JUnit 5 extension (or adopt the Page Object pattern for the pages) so each test suite focuses only on the interaction and assertions. That way, adding a “count items in list” test would only require a new test method or a small new class with minimal duplication.
