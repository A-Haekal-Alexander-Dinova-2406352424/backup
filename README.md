# eShop

## Refleksi 1

Saat membangun fitur EShop (create/list/edit/delete), saya berusaha menjaga kode tetap rapi dengan memisahkan tanggung jawab ala MVC ke paket `controller`, `service`, `repository`, dan `model`. Pemisahan ini membuat setiap class punya peran yang jelas: controller mengurus HTTP/HTML, service memegang logika bisnis, dan repository menangani penyimpanan data (saat ini masih in-memory). Saya menggunakan penamaan yang deskriptif seperti `ProductServiceImpl` dan method yang kecil seperti `productListPage()` supaya alurnya mudah dibaca sebagai rangkaian use-case. Untuk maintainability, saya menghindari duplikasi proses "ambil semua produk lalu ubah jadi list" dengan memusatkannya di layer service. Dari sisi secure coding yang sederhana, server yang menghasilkan `productId` (UUID) saat create, bukan menerima ID dari client, sehingga pengguna tidak bisa menentukan ID sesuka hati ketika membuat produk baru. Saya juga menjaga model data tetap bertipe tegas (misalnya quantity sebagai `int`) dan menggunakan endpoint POST untuk aksi yang mengubah state. Kekurangan yang masih ada adalah validasi input masih banyak bergantung pada validasi HTML (`required`, `min`) di sisi client; di aplikasi nyata sebaiknya ada validasi di server (misalnya Bean Validation) dan penanganan error yang baik saat input tidak valid. Peningkatan lain yang penting adalah menambahkan autentikasi/otorisasi sebelum mengizinkan edit/delete, serta menghindari mengekspos objek mutable secara langsung dari repository agar perubahan tidak "bocor" tanpa kontrol.

## Refleksi 2

1. Setelah menulis unit test, saya merasa lebih percaya diri karena perubahan di model/repository bisa cepat terdeteksi. Menurut saya, jumlah unit test yang "ideal" di sebuah class tidak bisa ditentukan dengan angka tetap; lebih masuk akal jika mengikuti banyaknya perilaku (behavior) dan edge case yang dimiliki class tersebut. Saya biasanya mengelompokkan test berdasarkan perilaku dan memastikan setiap test fokus pada satu skenario. Selain happy path, saya juga mencoba menambahkan skenario negatif (misalnya update/delete untuk produk yang tidak ada) karena di situlah bug sering muncul. Untuk menilai apakah test sudah "cukup", saya memakai code coverage sebagai petunjuk awal, lalu mengecek lagi apakah aturan bisnis penting dan batasan input benar-benar diuji dengan assertion yang kuat. Coverage bisa menunjukkan baris mana yang belum tersentuh, tetapi tidak menjamin kualitas assertion atau kombinasi input yang diuji. Jadi, 100% coverage tidak otomatis berarti program bebas bug; test bisa meleset dari requirement, assertion bisa terlalu lemah, atau masalah integrasi (mapping HTTP dan template rendering) belum teruji.

2. Kalau saya menyalin setup yang sama (misalnya `serverPort`, `baseUrl`, `@Value`, dan `setupTest`) ke class functional test baru, kodenya akan cepat jadi repetitif dan lebih sulit dirawat. Duplikasi ini adalah clean code smell (melanggar prinsip DRY), karena perubahan kecil pada setup (contohnya format base URL) harus diperbarui di banyak tempat. Boilerplate yang berulang juga bisa mengaburkan intent dari tiap test, sehingga test jadi kurang enak dibaca. Dalam jangka panjang, setup yang diduplikasi bisa "ngedrift" dan memicu flaky test yang perilakunya tidak konsisten antar suite. Pendekatan yang lebih bersih adalah mengekstrak setup bersama ke base class/helper, membuat JUnit 5 extension, atau menerapkan Page Object pattern untuk halaman-halaman yang diuji, sehingga tiap suite fokus pada interaksi dan assertion saja. Dengan cara ini, menambah test seperti "menghitung jumlah item di list" cukup menambah method test (atau class kecil) tanpa mengulang boilerplate.
